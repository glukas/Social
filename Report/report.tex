% This is based on "sig-alternate.tex" V1.9 April 2009
% This file should be compiled with V2.4 of "sig-alternate.cls" April 2009
%
\documentclass{report}

\usepackage[english]{babel}
\usepackage{graphicx}
\usepackage{tabularx}
\usepackage{subfigure}
\usepackage{enumitem}
\usepackage{url}

\usepackage{color}
\definecolor{orange}{rgb}{1,0.5,0}
\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{java_keyword}{rgb}{0.37, 0.08, 0.25}
\definecolor{java_string}{rgb}{0.06, 0.10, 0.98}
\definecolor{java_comment}{rgb}{0.12, 0.38, 0.18}
\definecolor{java_doc}{rgb}{0.25,0.35,0.75}

% code listings

\usepackage{listings}
\lstloadlanguages{Java}
\lstset{
	language=Java,
	basicstyle=\scriptsize\ttfamily,
	backgroundcolor=\color{lightgray},
	keywordstyle=\color{java_keyword}\bfseries,
	stringstyle=\color{java_string},
	commentstyle=\color{java_comment},
	morecomment=[s][\color{java_doc}]{/**}{*/},
	tabsize=2,
	showtabs=false,
	extendedchars=true,
	showstringspaces=false,
	showspaces=false,
	breaklines=true,
	numbers=left,
	numberstyle=\tiny,
	numbersep=6pt,
	xleftmargin=3pt,
	xrightmargin=3pt,
	framexleftmargin=3pt,
	framexrightmargin=3pt,
	captionpos=b
}

% Disable single lines at the start of a paragraph (Schusterjungen)

\clubpenalty = 10000

% Disable single lines at the end of a paragraph (Hurenkinder)

\widowpenalty = 10000
\displaywidowpenalty = 10000
 
% allows for colored, easy-to-find todos

\newcommand{\todo}[1]{\textsf{\textbf{\textcolor{orange}{[[#1]]}}}}

% consistent references: use these instead of \label and \ref

\newcommand{\lsec}[1]{\label{sec:#1}}
\newcommand{\lssec}[1]{\label{ssec:#1}}
\newcommand{\lfig}[1]{\label{fig:#1}}
\newcommand{\ltab}[1]{\label{tab:#1}}
\newcommand{\rsec}[1]{Section~\ref{sec:#1}}
\newcommand{\rssec}[1]{Section~\ref{ssec:#1}}
\newcommand{\rfig}[1]{Figure~\ref{fig:#1}}
\newcommand{\rtab}[1]{Table~\ref{tab:#1}}
\newcommand{\rlst}[1]{Listing~\ref{#1}}

% General information

\title{Distributed Systems -- Assignment 4 - Report}

% Use the \alignauthor commands to handle the names
% and affiliations for an 'aesthetic maximum' of six authors.

\numberofauthors{3} %  in this sample file, there are a *total*
% of EIGHT authors. SIX appear on the 'first-page' (for formatting
% reasons) and the remaining two appear in the \additionalauthors section.
%
\author{
% You can go ahead and credit any number of authors here,
% e.g. one 'row of three' or two rows (consisting of one row of three
% and a second row of one, two or three).
%
% The command \alignauthor (no curly braces needed) should
% precede each author name, affiliation/snail-mail address and
% e-mail address. Additionally, tag each line of
% affiliation/address with \affaddr, and tag the
% e-mail address with \email.
%
% 1st. author
\alignauthor Student One\\
	\affaddr{ETH ID XX-XXX-XXX}\\
	\email{one@student.ethz.ch}
% 2nd. author
\alignauthor Student Two\\
	\affaddr{ETH ID XX-XXX-XXX}\\
	\email{two@student.ethz.ch}
% 3rd. author
\alignauthor Student Three\\
	\affaddr{ETH ID XX-XXX-XXX}\\
	\email{three@student.ethz.ch}
\and  % use '\and' if you need 'another row' of author names
% 4th. author
\alignauthor Student Four\\
 	\affaddr{ETH ID XX-XXX-XXX}\\
 	\email{four@student.ethz.ch}
% 5th. author
\alignauthor Student Five\\
 	\affaddr{ETH ID XX-XXX-XXX}\\
 	\email{five@student.ethz.ch}
% 6th. author
\alignauthor Student Six\\
 	\affaddr{ETH ID XX-XXX-XXX}\\
 	\email{six@student.ethz.ch}
}


\begin{document}

\maketitle

\begin{abstract}
Concisely state (i) which Android device you used, (ii) which tasks you completed and which are working correctly or limited, and (iii) what your specific enhancements are.
\end{abstract}

\section{Introduction}



\section{Architecture}

For the implementation of our project we divided it into 5 main layers : User Interface,
 DataBase,
 Server/Networking, 
 Security and Protocol  

\subsection{User Interface}




\subsection{Server/Networking}
\textbf{Hardware and Setup}\newline
\indent The server in our project is only responsible for forwarding and, if the user is not connected, buffering the messages. It doesnâ€™t store the user data in a permanent way and also cannot read the user messages, since the data is encrypted. 
Because of these circumstances we decided on having a small, lightweight server. Therefore we used a Raspberry Pi Modell B [1]. The R-Pi runs an ARM 700 MHz processor and 512 MB of RAM. It is connected with an Ethernet cable to the network.
The R-Pi is running Raspbian, a linux distribution, adapted for Raspberry Pi devices. The whole installation is headless and accessed through SSH. This setup is very energy efficient. 
Since we do not have access to a static Public IP, we have a client in the network, that updates a DNS entry [2] every minute and guarantees, that our server is always reachable over the same address. 

\textbf{Software}\newline
\indent Because of the limited resources the hardware is offering. The server application also needs to be very lightweight. To avoid too much thread-switching overhead, to efficiently use the resources and offer good scalability, we decided on a Non-blocking I/O (NIO) [3][4] approach to design the server application. The core-application consists of two threads running in parallel. The server thread, which implements the NIO server and a worker thread which processes the incoming data and decides what to do with the messages. Based on the public header, the worker thread reads the sender, the recipient and the kind of message and then handles the message accordingly.
Two data structures are responsible to process the messages in a meaningful way. The first is a simple HashMap which stores the connected users and the corresponding sockets. If a user is not connected, then the message gets buffered in a user specific PriorityQueue. The time a user connects again, he can request all messages he missed when he was offline. Since the hardware has not too much memory available, the server does not guarantee to store all messages until the user connects again. In those cases, the user needs to rerequest the data from his friends.
Alongside the core-application, a monitor thread is running. The task of the monitor thread is to periodically check the connectivity and memory usage of the application. In case of failure and/or too less memory available, the monitor thread can command the server to drop the oldest messages or even to restart the whole server thread. 



\subsection{Security}
The cryptography is peer-to-peer. The server acts as a relay for the client messages and is untrusted.

On first application start, every peer generates a broadcast key. A broadcast key is a pair $(k_1, k_2)$ where $k_1$ is used for encryption and $k_2$ for message authentication.

To establish a friendship, peers exchange their contact information and broadcast keys over Near-Field-Communication. Keys are exchanged in plain. This is reasonable under the assumption that the exchange occurs in a relatively private place.

To post a message on Bob's wall, Alice encrypts and authenticates the post under Bob's key and broadcasts it to all friends of Bob. Since all friends of Bob share Bob's key, it is possible to post a message by encrypting it only once. Encryption is done by combining AES-128 in CBC mode and an HMAC based on SHA256 in an "Encrypt-then-Authenticate" fashion. More concretely the encryption function for message $m$ with public header $h$ is \newline
$Enc_{(k_1, k_2)}(h|m) = h | MAC_{k_2}(h | Enc_{k_1}(m)) | Enc_{k_1}(m)$.\newline
Assuming that no friends are compromised, this gives us authenticity and chosen plaintext security for the transmission of posts. A compromised peer exposes the communication of all of his or her friends. However, it is very expensive to eavesdrop or manipulate communication on a large scale, as there is no central storage or transmission of key material.

\subsection{Database}

\subsection{Protocol}
Finally we have the protocol layer which is responsible for connecting the layers mentioned above, that means the task to provide appropriate interfaces, methods and structures for communicating between each layer.






\section{Testing and Evaluation}

\section{Conclusion}

Give an overall conclusion that summarizes the main challenges you encountered and your lessons learned.

% The following two commands are all you need in the
% initial runs of your .tex file to
% produce the bibliography for the citations in your paper.
\bibliographystyle{abbrv}
\bibliography{report}  % sigproc.bib is the name of the Bibliography in this case
% You must have a proper ".bib" file

%\balancecolumns % GM June 2007

\end{document}
