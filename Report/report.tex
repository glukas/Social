% This is based on "sig-alternate.tex" V1.9 April 2009
% This file should be compiled with V2.4 of "sig-alternate.cls" April 2009
%
\documentclass{report}

\usepackage[english]{babel}
\usepackage{graphicx}
\usepackage{tabularx}
\usepackage{subfigure}
\usepackage{enumitem}
\usepackage{url}
\usepackage{float}

\usepackage{color}
\definecolor{orange}{rgb}{1,0.5,0}
\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{java_keyword}{rgb}{0.37, 0.08, 0.25}
\definecolor{java_string}{rgb}{0.06, 0.10, 0.98}
\definecolor{java_comment}{rgb}{0.12, 0.38, 0.18}
\definecolor{java_doc}{rgb}{0.25,0.35,0.75}

% code listings

\usepackage{listings}
\lstloadlanguages{Java}
\lstset{
	language=Java,
	basicstyle=\scriptsize\ttfamily,
	backgroundcolor=\color{lightgray},
	keywordstyle=\color{java_keyword}\bfseries,
	stringstyle=\color{java_string},
	commentstyle=\color{java_comment},
	morecomment=[s][\color{java_doc}]{/**}{*/},
	tabsize=2,
	showtabs=false,
	extendedchars=true,
	showstringspaces=false,
	showspaces=false,
	breaklines=true,
	numbers=left,
	numberstyle=\tiny,
	numbersep=6pt,
	xleftmargin=3pt,
	xrightmargin=3pt,
	framexleftmargin=3pt,
	framexrightmargin=3pt,
	captionpos=b
}

% Disable single lines at the start of a paragraph (Schusterjungen)

\clubpenalty = 10000

% Disable single lines at the end of a paragraph (Hurenkinder)

\widowpenalty = 10000
\displaywidowpenalty = 10000
 
% allows for colored, easy-to-find todos

\newcommand{\todo}[1]{\textsf{\textbf{\textcolor{orange}{[[#1]]}}}}

% consistent references: use these instead of \label and \ref

\newcommand{\lsec}[1]{\label{sec:#1}}
\newcommand{\lssec}[1]{\label{ssec:#1}}
\newcommand{\lfig}[1]{\label{fig:#1}}
\newcommand{\ltab}[1]{\label{tab:#1}}
\newcommand{\rsec}[1]{Section~\ref{sec:#1}}
\newcommand{\rssec}[1]{Section~\ref{ssec:#1}}
\newcommand{\rfig}[1]{Figure~\ref{fig:#1}}
\newcommand{\rtab}[1]{Table~\ref{tab:#1}}
\newcommand{\rlst}[1]{Listing~\ref{#1}}

% General information

\title{Distributed Systems -- Assignment 4 - Report}

% Use the \alignauthor commands to handle the names
% and affiliations for an 'aesthetic maximum' of six authors.

\numberofauthors{3} %  in this sample file, there are a *total*
% of EIGHT authors. SIX appear on the 'first-page' (for formatting
% reasons) and the remaining two appear in the \additionalauthors section.
%
\author{
% You can go ahead and credit any number of authors here,
% e.g. one 'row of three' or two rows (consisting of one row of three
% and a second row of one, two or three).
%
% The command \alignauthor (no curly braces needed) should
% precede each author name, affiliation/snail-mail address and
% e-mail address. Additionally, tag each line of
% affiliation/address with \affaddr, and tag the
% e-mail address with \email.
%
% 1st. author
\alignauthor Student One\\
	\affaddr{ETH ID XX-XXX-XXX}\\
	\email{one@student.ethz.ch}
% 2nd. author
\alignauthor Student Two\\
	\affaddr{ETH ID XX-XXX-XXX}\\
	\email{two@student.ethz.ch}
% 3rd. author
\alignauthor Student Three\\
	\affaddr{ETH ID XX-XXX-XXX}\\
	\email{three@student.ethz.ch}
\and  % use '\and' if you need 'another row' of author names
% 4th. author
\alignauthor Student Four\\
 	\affaddr{ETH ID XX-XXX-XXX}\\
 	\email{four@student.ethz.ch}
% 5th. author
\alignauthor Student Five\\
 	\affaddr{ETH ID XX-XXX-XXX}\\
 	\email{five@student.ethz.ch}
% 6th. author
\alignauthor Samuel Schmid\\
 	\affaddr{ETH ID 10-919-991}\\
 	\email{schmisam@student.ethz.ch}
}


\begin{document}

\maketitle

\begin{abstract}
Social is an Android application that allows users to share thoughts and impressions with their friends by posting text or image messages on their profiles.
The distinctive feature of Social is that instead of using a client-server architecture like todays well known social networks, which store all data on a server, it uses a peer-to-peer approach and only stores data on user devices, giving them a better control over their own data.
The motivation to provide a social networking service that focuses on privacy and security comes from the invasive privacy policies that such communication services nowadays have.
\end{abstract}

\section{Problem Statement}

Going into this project we considered following problems we would have to solve: \newline
Consistent storage/retrieval of posts and information:  \newline
We have to make sure that if an user posts on a wall every user able to access that wall should get it immediately if online or be able to retrieve it later. This ensures that eventually every user sees the same posts.  \newline
Logical consistency of the posts:  \newline
Posts user make with the knowledge of certain post should be displayed after that post.  \newline
Encryption of the posts and information in a suitable way:  \newline
Posting on a certain wall should only require to encrypt the post once. Every friend of the owner of the wall should be able to read the post but noone else. \newline

\section{Architecture}





\section{Implementation}
For the implementation of our project we divided it into 5 main layer corresponding the problems: User Interface, Database, Server/Networking, Security, Protocol

\begin{figure}[H]
\vspace{-2mm} % use negative white space to fix too large gaps
	\centering
    \includegraphics[width=\columnwidth]{Architecture.png}

    
    \caption{Overview over the general Communication and Layers}
\end{figure}

\subsection{User Interface}

The main activity holds a navigation bar to switch between the friends list and the user's own wall (Figure 1).

\begin{figure}[H]
	\centering
	\subfigure[Figure 1]{
	    \includegraphics[height=4cm]{Figure_1}

	}
	\hfill
	\subfigure[Figure 2]{
	    \includegraphics[height=4cm]{Figure_2}

	}
	\hfill
	\subfigure[Figure 3]{
	    \includegraphics[height=4cm]{Figure_3}

	}
	
\end{figure}

A second activity is for viewing a friend's wall. This activity is started when clicking one of the friends (Figure 2) or immediately after establishing a new friendship. The wall is implmented using the same fragment the user sees when looking at his or her own wall.\newline

The last activity is for displaying incoming friendship requests. It pops up when two phones are held close together and one of the users taps the screen, initiating a friendship request (Figure 3).

Upon first opening the application, the user is prompted to choose a username for registration which then gets saved in the local database (Figure 6).

In the wall fragment the user can see an interface for adding new posts. There we have a button for adding pictures to a post. Pictures can be taken from the gallery or a new picture can be taken (Figures 4 and 5). A send button allows posting the content the user entered in the textView. \begin{figure}[H]
	\centering
	\subfigure[Figure 4]{
	    \includegraphics[height=4cm]{Figure_4}

	}
	\hfill
	\subfigure[Figure 5]{
	    \includegraphics[height=4cm]{Figure_5}

	}
	\hfill
	\subfigure[Figure 6]{
	    \includegraphics[height=4cm]{Figure_6}

	}
	
\end{figure}

\subsection{Protocol}

To communicate between different peers we use messages which contain information about the content, sender and receiver. That information is distributed to three parts which make up following layout.
\begin{figure}[H]

	\centering
    \includegraphics[width=\columnwidth]{Layout.png}
    \lfig{Layout}
    \vspace{-5mm} % use negative white space to fix too large gaps
\end{figure}
The information stored by the PublicHeader is used by the server for appropiate handling of the message.  

The main responsibility of the protocol part lies in maintaining the consistency of the system. To achieve that, the post count of the wall and the respective virtual clock values of each post are of importance. The clock values will then guarantee the right order of posts. Regarding the implementation it was only of significance that if one user makes multiple posts on a certain wall that this user's posts will be in the right order, since every wall has its own virtual clock and uniqueness of values between walls is not assured.

Crucial for the consistency are following kind of events:\newline
\textbf{Request of data:} This happens when a peer comes back online and wants to access a certain wall.  
In case the target is the own wall it requests all buffered posts the server stored in its absence.
If it wants to access an other wall, there are following two cases:\newline
Case 1 : Wall owner is online
Responding to the data request, the target peer will send a message containing its wall's post count and maximum virtual clock value. If the local post count is $\leq$ the reported post count, a request for all posts with value $\geq$ the reported virtual clock value is sent.\newline
Case 2: Wall owner is offline
In this case the server will send the peer all cached posts of the target peer's wall.\newline
\textbf{Making a post:}
To keep the virtual clock values up to date the outgoing post's value is the wall's most recent clock value incremented by 1.\newline
To maintain consistency on what posts are really in the system, in case the target is the own wall, the instant of commit to the local database is decisive.
Else if the target is an other wall, the instant the server receives the post message is crucial. Our assumption here is that the server does not crash before properly delivering the posts it received. TCP guarantees that each post send is also received.\newline
\textbf{Receiving a post:}
Whenever a post message is received the maximum clock value gets set to the maximum of the received value and itself.  The wall's post count increases by one after each receiving.

\subsection{Security}
The cryptography is peer-to-peer. The server acts as a relay for the client messages and is untrusted.

On first application start, every peer generates a broadcast key. A broadcast key is a pair $(k_1, k_2)$ where $k_1$ is used for encryption and $k_2$ for message authentication.

To establish a friendship, peers exchange their contact information and broadcast keys over Near-Field-Communication. Keys are exchanged in plain. This is reasonable under the assumption that the exchange occurs in a relatively private place.

To post a message on Bob's wall, Alice encrypts and authenticates the post under Bob's key and sends the post to the server for relaying to Bob and his friends. Since all friends of Bob share Bob's key, it is possible to post a message by encrypting it only once. Encryption is done by combining AES-128 in CBC mode and an HMAC based on SHA256 in an "Encrypt-then-Authenticate" fashion. More concretely the encryption function for message $m$ with public header $h$ is \newline
$Enc_{(k_1, k_2)}(h|m) = h | MAC_{k_2}(h | Enc_{k_1}(m)) | Enc_{k_1}(m)$.
%TODO footnotes for AES, CBC, HMAC, SHA256
\newline
Assuming that no friends are compromised, this gives us authenticity and secrecy for the transmission of posts. A compromised peer exposes the communication of all of his or her friends. However, it is very expensive to eavesdrop or manipulate communication on a large scale, as there is no central storage or transmission of key material.

\subsection{Database}
%Structure
In order to store persistently the user's data on his or her device it tourned out that the most suitable approach between the ones offered by the Android operating system [1], was to use a SQLite database [2]. This decision was mainly based on the two following application requirements:
1) the user data needs to be structured;
2) it shouldn't be possible to access the data from outside the application.
The structure of the database is simple and consists of only two tables: one storing the users' data and the other storing the posts.

The user table stores id, username and other information needed by different layers, e.g. the number of messages on the user's wall for the protocol layer and the keys for the secutity layer. The primary key is the id, since it's unique with high probability among all users.

\begin{figure}[H]
	\centering
    \includegraphics[width=\columnwidth]{users_table_example.png}
    \lfig{users_table_example}
    \vspace{-5mm} % use negative white space to fix too large gaps
	\caption{user table with example data ("..." means that the data is too long to fit).}
\end{figure}

The post table stores the single posts that are part of the user's wall or one of his/hers friend's wall. 
A post contains an id, the id of who posted it, the id of the user on whose wall it was posted, date and time when it was received, text and/or image content.Id, poster$\_$id and wall$\_$id form the primary key, while both poster$\_$id and wall$\_$id are foreign key references to the users table.

\begin{figure}[H]
	\centering
    \includegraphics[width=\columnwidth]{post_table_example.png}
    \lfig{post_table_example}
    \vspace{-5mm} % use negative white space to fix too large gaps
	\caption{post table with example data.}
\end{figure}

%Implementation

An interface provides access to the functionalities of the database for the other layers, which don't have another way to access the data. This allows a better control over the state of the database, in particular for assuring consistency to the whole system, and made easier throughout the implementation process, because the structure and the methods evolved over time.
Extending the SQLiteOpenHelper class [3] helped to make database creation and version control easier to manage.
All core methods are implemented using the functions already provided by the SQLiteDatabase class [4], in particular insert(), update(), delete() and query(). This methods are divided into three categories:
- user, to manage data about the owner of the device;
- friend, to manage data about all his or her friends;
- post, to manage data about all posts saved in the device.

\subsection{Server/Networking}
\textbf{Hardware and Setup}\newline
\indent The server in our project is only responsible for forwarding, buffering and caching the messages. It doesn't store the user data in a permanent way and also cannot read the user messages, since the data is encrypted. 
Because of these circumstances we decided on having a small, lightweight server. Therefore we used a Raspberry Pi Modell B [1]. The R-Pi runs an ARM 700 MHz processor and 512 MB of RAM. It is connected with an Ethernet cable to the network.
The R-Pi is running Raspbian, a linux distribution, adapted for Raspberry Pi devices. The whole installation is headless and accessed through SSH. This setup is very energy efficient. 
Since we do not have access to a static Public IP, we have a client in the network, that updates a DNS entry [2] every minute and guarantees, that our server is always reachable over the same address. 

\textbf{Software}\newline
\indent Because of the limited resources the hardware is offering the server application needs to be very lightweight. To avoid too much thread-switching overhead, to efficiently use the resources and offer good scalability, we decided on a Non-blocking I/O (NIO) [3][4] approach to design the server application. The core-application consists of two threads running in parallel. The server thread, which implements the NIO server and a worker thread which processes the incoming data and decides what to do with the messages. Based on the public header the worker thread handles the message accordingly.
%Two data structures are responsible to process the messages in a meaningful way. The first is a HashMap which stores the connected users and the corresponding sockets. If a user is not connected, then the posts get buffered in a user specific PriorityQueue. The time a user connects again he or she can request all posts on his or her wall missed whilst offline.
Alongside the core-application, a monitor thread is running. The task of the monitor thread is to periodically check the connectivity and memory usage of the application. In case of failure and/or too less memory available, the monitor thread can command the server to drop the oldest messages in the cache or to restart the server thread. 











\section{Testing}


\section{Outlook}

The reliance on a message relaying server could be further reduced by enabling peers to directly communicate. The main issue in implementing this is NAT-traversal, though solutions to achieve this exist.

The security of the key exchange mechanism could be improved by first exchanging some public keys, and then exchanging the broadcast keys encrypted under those public keys.

One issue is that current monetization models seem hard to apply to our approach, as no information about the content users are sharing is available. To provide userful advertisement, the pseudo-anonymous network information available to the server might prove to be sufficient. 

\section{Conclusion}

Mobile devices are powerful enough to implement a mostly peer-to-peer social network. Our architecture might provide reduced infrastructure costs compared to centralized systems, as little or no permanent storage is required. Availability is acceptable: Users can always access content they have seen before, and eventually they will receive all updates. 
The system should scale well, as the server component could be very easily replicated without the need for complex synchronisation mechanisms.




% The following two commands are all you need in the
% initial runs of your .tex file to
% produce the bibliography for the citations in your paper.
\bibliographystyle{abbrv}
\bibliography{report}  % sigproc.bib is the name of the Bibliography in this case
% You must have a proper ".bib" file

%\balancecolumns % GM June 2007

\end{document}
